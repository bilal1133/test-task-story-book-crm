import { ErrorMessage } from '@app/constants';
import {
  copyObjectShallowNoClientSideProperties, generateTimestampIsoFormatTimeZoneUTC
} from '@app/helpers';
import {
  DBDocument, Timestamp
} from '@app/types';
import {
  FieldValue, firestoreRef
} from '@lolab/database';
import { firestoreAdminRef } from '@lolab/database/firebase/admin.api-only';
import { isPlainObject } from 'lodash';
import { nanoid } from 'nanoid';

export type _firestoreRef = typeof firestoreRef | typeof firestoreAdminRef;

const isValidPath = ({ path }: { path: DBDocument['_path']; }): boolean => {
  if (!path.length || (path.length && (path.startsWith('/') || /\/{2,}/g.test(path)))) {
    // matches `` and `an//invalid//path` and `/another/invalid/path`
    // throw new Error(`isValidPath -> invalid path: ${path}`); // TODO: log online
    return false;
  }
  return true;
};

const getPathNumberOfSegments = ({ path }: { path: DBDocument['_path'] }): number => path.split('/').filter(Boolean).length;

const isCollectionPath = ({ path }: { path: string; }): boolean => isValidPath({ path }) && (getPathNumberOfSegments({ path }) % 2 === 1);
// ^^^^ a valid collection path will always have an ODD number of segments

const isDocumentPath = ({ path }: { path: string; }): boolean => isValidPath({ path }) && (getPathNumberOfSegments({ path }) % 2 === 0);
// ^^^^ a valid document path will always have an EVEN number of segments

export const isValidCollectionPath = ({ path }: { path: string; }): boolean => isValidPath({ path }) && isCollectionPath({ path });

export const isValidDocumentPath = ({ path }: { path: string; }): boolean => isValidPath({ path }) && isDocumentPath({ path });

export const getOrGenerateDocumentPath = (path: string): DBDocument & { isAutoGeneratedId: boolean; } => {
  path = path.trim();

  if (!isValidPath({ path })) {
    throw new Error(`getOrGenerateDocumentPath -> invalid path: ${path}`);
  }

  let _id: string | null = null;
  let _path: string | null = null;
  let isAutoGeneratedId = false;

  if (isCollectionPath({ path })) {
    // matches `path/to/collection` and `path/to/collection/`
    _id = nanoid();                                          // <auto-generated-id>
    _path = `${path}${path.endsWith('/') ? '' : '/'}${_id}`; // path/to/collection/<auto-generated-id>
    isAutoGeneratedId = true;

  } else if (isDocumentPath({ path })) {
    // matches `path/to/document/id` and `path/to/document/id/`
    _path = path.endsWith('/')
      ? path.split('/').filter(Boolean).join('/') // from `path/to/document/id/` to `path/to/document/id`
      : path;
    const paths = path.split('/'); // [path, to, document, id]
    _id = paths[paths.length - 1]; // id

  } else {
    throw new Error(`getOrGenerateDocumentPath -> invalid path: ${path}`);
  }

  return {
    _id,
    _path,
    isAutoGeneratedId
  };
};

// CREATE DOCUMENT
export const createDocument = async<T extends DBDocument>({
  path,
  doc,
  _firestoreRef
}: {
  path: string;
  doc: T;
  _firestoreRef: _firestoreRef;
}): Promise<DBDocument> => {
  // BEWARE: not guarding against 'isValidDocumentPath' because the path will be auto-generated on a need basis
  try {
    console.group('createDocument');
    console.log('path', path);
    console.log('doc', doc);
    const {
      _id, _path
    } = getOrGenerateDocumentPath(path);
    console.log('_id', _id);
    console.log('_path', _path);
    const timestamp = generateTimestampIsoFormatTimeZoneUTC();
    console.log('timestamp', timestamp);
    console.groupEnd();
    await _firestoreRef().doc(_path).set({
      ...copyObjectShallowNoClientSideProperties<typeof doc>(doc),
      _id,
      _path,
      createdAt: timestamp,
      updatedAt: timestamp
    });
    return {
      _id,
      _path
    };
  } catch (error) {
    // log error
    console.log('ERROR createDocument', error);
    throw error;
  }
};

// UPDATE DOCUMENT
// BEWARE: the dot notation to update nested object CAN be used here, because it's only valid for .update() and NOT for .set()
export const updateDocument = async<T extends DBDocument>({
  path,
  doc,
  _firestoreRef
}: {
  path: string;
  doc: Partial<T>;
  _firestoreRef: _firestoreRef;
}): Promise<DBDocument> => {
  // BEWARE: not guarding against 'isValidDocumentPath' because the path will be auto-generated on a need basis
  if (Object.entries(doc).some(([
    key,
    val
  ]) => isPlainObject(val) && !key.includes('.'))) {
    // ^^^^ BEWARE trying to save a nested object WITHOUT the dot notation, which is very UNSAFE as it will override whatever is present.
    // log error
    console.log('ERROR updateDocument', ErrorMessage.PayloadMalformatted);
    throw new Error(ErrorMessage.PayloadMalformatted);
  }
  try {
    console.group('updateDocument');
    console.log('path', path);
    console.log('doc', doc);
    const {
      _id, _path
    } = getOrGenerateDocumentPath(path);
    console.log('_id', _id);
    console.log('_path', _path);
    const timestamp = generateTimestampIsoFormatTimeZoneUTC();
    console.log('timestamp', timestamp);
    console.groupEnd();
    await _firestoreRef().doc(_path).update({
      ...copyObjectShallowNoClientSideProperties<typeof doc>(doc),
      _id,
      _path,
      updatedAt: timestamp
    });
    return {
      _id,
      _path
    };
  } catch (error) {
    // log error
    console.log('ERROR updateDocument', error);
    throw error;
  }
};

// CREATE OR MERGE DOCUMENT (create if not exist, else merge)
// BEWARE: the dot notation to update nested object CANNOT be used here
// see https://medium.com/feedflood/update-data-in-cloud-firestore-merge-true-in-set-operation-166703040de
// see https://stackoverflow.com/questions/46597327/difference-between-set-with-merge-true-and-update
// i.e. set without merge will overwrite a document or create it if it doesn't exist yet
// i.e. set with merge will update fields in the document or create it if it doesn't exists
// i.e. update will update fields but will fail if the document doesn't exist
// i.e. create will create the document but fail if the document already exists
// also, for set you always have to provide document-shaped data
// also, with update you can also use field paths for updating nested values
export const createOrMergeDocument = async<T extends DBDocument>({
  path,
  doc,
  _firestoreRef
}: {
  path: string;
  doc: Partial<T>;
  _firestoreRef: _firestoreRef;
}): Promise<DBDocument> => {
  // BEWARE: not guarding against 'isValidDocumentPath' because the path will be auto-generated on a need basis
  try {
    console.group('createOrMergeDocument');
    console.log('path', path);
    console.log('doc', doc);
    const {
      _id, _path, isAutoGeneratedId
    } = getOrGenerateDocumentPath(path);
    console.log('_id', _id);
    console.log('_path', _path);
    const timestamp: Timestamp  = { updatedAt: generateTimestampIsoFormatTimeZoneUTC() };
    if (isAutoGeneratedId) {
      timestamp.createdAt = timestamp.updatedAt;
    }
    console.log('timestamp', timestamp);
    console.groupEnd();
    await _firestoreRef().doc(_path).set({
      ...copyObjectShallowNoClientSideProperties<typeof doc>(doc),
      _id,
      _path,
      ...timestamp
    }, { merge: true });
    return {
      _id,
      _path
    };
  } catch (error) {
    // log error
    console.log('ERROR createOrMergeDocument', error);
    throw error;
  }
};

// DELETE DOCUMENT
export const deleteDocument = async ({
  path,
  _firestoreRef
}: {
  path: string;
  _firestoreRef: _firestoreRef;
}): Promise<DBDocument> => {
  if (!isValidDocumentPath({ path })) {
    // log error
    console.log('ERROR deleteDocument', ErrorMessage.DocumentPathInvalid);
    throw new Error(ErrorMessage.DocumentPathInvalid);
  }
  try {
    console.group('deleteDocument');
    console.log('path', path);
    const {
      _id, _path
    } = getOrGenerateDocumentPath(path);
    console.log('_id', _id);
    console.log('_path', _path);
    console.groupEnd();
    await _firestoreRef().doc(_path).delete();
    return {
      _id,
      _path
    };
  } catch (error) {
    // log error
    console.log('ERROR deleteDocument', error);
    throw error;
  }
};

// DELETE FIELD IN DOCUMENT
// BEWARE: the dot notation to update nested object CAN be used here, because it's only valid for .update() and NOT for .set()
export const deleteDocumentField = async<T extends DBDocument>({
  path,
  docField,
  _firestoreRef
}: {
  path: string;
  docField: keyof T;
  _firestoreRef: _firestoreRef;
}): Promise<DBDocument> => {
  if (!isValidDocumentPath({ path })) {
    // log error
    console.log('ERROR deleteDocumentField', ErrorMessage.DocumentPathInvalid);
    throw new Error(ErrorMessage.DocumentPathInvalid);
  }
  try {
    console.group('deleteDocumentField');
    console.log('path', path);
    console.log('docField', docField);
    const {
      _id, _path
    } = getOrGenerateDocumentPath(path);
    console.log('_id', _id);
    console.log('_path', _path);
    console.groupEnd();
    await _firestoreRef().doc(_path).update({ [docField]: FieldValue.delete() });
    return {
      _id,
      _path
    };
  } catch (error) {
    // log error
    console.log('ERROR deleteDocumentField', error);
    throw error;
  }
};

// DELETE ARRAY VALUE IN DOCUMENT
// BEWARE: the dot notation to update nested object CAN be used here, because it's only valid for .update() and NOT for .set()
export const deleteDocumentArrayValue = async<T extends DBDocument>({
  path,
  docField,
  valueToRemove,
  _firestoreRef
}: {
  path: string;
  docField: keyof T;
  valueToRemove: T[keyof T];
  _firestoreRef: _firestoreRef;
}): Promise<DBDocument> => {
  if (!isValidDocumentPath({ path })) {
    // log error
    console.log('ERROR deleteDocumentArrayValue', ErrorMessage.DocumentPathInvalid);
    throw new Error(ErrorMessage.DocumentPathInvalid);
  }
  try {
    console.group('deleteDocumentArrayValue');
    console.log('path', path);
    console.log('docField', docField);
    const {
      _id, _path
    } = getOrGenerateDocumentPath(path);
    console.log('_id', _id);
    console.log('_path', _path);
    console.groupEnd();
    await _firestoreRef().doc(_path).update({ [docField]: FieldValue.arrayRemove(valueToRemove) });
    return {
      _id,
      _path
    };
  } catch (error) {
    // log error
    console.log('ERROR deleteDocumentArrayValue', error);
    throw error;
  }
};

// PUSH ARRAY VALUE IN DOCUMENT
// BEWARE: the dot notation to update nested object CAN be used here, because it's only valid for .update() and NOT for .set()
export const pushDocumentArrayValue = async<T extends DBDocument>({
  path,
  docField,
  valueToPush,
  _firestoreRef
}: {
  path: string;
  docField: keyof T;
  valueToPush: T[keyof T];
  _firestoreRef: _firestoreRef;
}): Promise<DBDocument> => {
  if (!isValidDocumentPath({ path })) {
    // log error
    console.log('ERROR pushDocumentArrayValue', ErrorMessage.DocumentPathInvalid);
    throw new Error(ErrorMessage.DocumentPathInvalid);
  }
  try {
    console.group('pushDocumentArrayValue');
    console.log('path', path);
    console.log('docField', docField);
    const {
      _id, _path
    } = getOrGenerateDocumentPath(path);
    console.log('_id', _id);
    console.log('_path', _path);
    console.groupEnd();
    await _firestoreRef().doc(_path).update({ [docField]: FieldValue.arrayUnion(valueToPush) });
    return {
      _id,
      _path
    };
  } catch (error) {
    // log error
    console.log('ERROR pushDocumentArrayValue', error);
    throw error;
  }
};
